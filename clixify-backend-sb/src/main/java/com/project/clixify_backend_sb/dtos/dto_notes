DTO (Data Transfer Object) is a simple object used to transfer data between layers (e.g. Controller -> Service -> Repository) or between different applications.
- Acts as a contract between client and server for API communication

In the context of DTOs, a "contract" means a formal agreement or specification that defines:

Structure: The exact fields and their data types that will be exchanged
Rules: Validation rules and constraints for the data
Versioning: How the data structure may evolve over time
Documentation: Clear expectations for both client and server
For example, in your RegisterRequest DTO, the contract specifies that when registering a user, the client must provide:

A username (string)
An email (string, must be valid email format)
A password (string, with certain complexity requirements)
This contract ensures that:

Frontend developers know exactly what data to send
Backend developers know exactly what data to expect
Both sides can validate the data against the agreed structure
Changes to the data structure are explicitly managed and documented
If either side violates this contract (e.g., frontend sends invalid data or backend expects different fields), the API will fail with appropriate validation errors. This makes DTOs a crucial part of your API's design and documentation.



Why use a DTO package in Spring Boot?

1. Separation of Concerns

- Your entities (like User) represent how data is stored in the database.
- Your DTOs (like RegisterRequest) represent how data is received/sent through APIs.
- This separation avoids leaking database structure to the outside world.

2. Security

- For example, the User entity might have fields like id, passwordHash, roles.
- You donâ€™t want users to pass or see all these fields directly via API.
- A RegisterRequest DTO only contains what you need from the client (username, email, password).

3. Validation

- You can put validation annotations (@NotNull, @Email, @Size) directly on DTO fields.
- This ensures the request payload is validated before converting it into an entity.

4. Flexibility

- API contract (DTO) can evolve independently from DB schema (Entity).
- You can have multiple DTOs (RegisterRequest, LoginRequest, UserResponse) for different endpoints, even if all map to the same User entity.

Because of these reasons, we are using DTOs in our application and not using entities directly in our controllers.

Here we have__________________

1. RegisterRequest
   - Used in: User registration endpoint (`/api/auth/register`)
   - Purpose: Defines the required fields for new user registration
   - Fields: username, email, password, roles
   - Validations: Ensures proper email format, password strength, and required fields
   - Security: Never exposes sensitive data, used only for registration input

2. LoginRequest
   - Used in: User authentication endpoint (`/api/auth/login`)
   - Purpose: Handles user login credentials
   - Fields: username, password
   - Validations: Basic field validations before authentication
   - Security: Transient data used only for authentication

3. UrlMappingDTO
   - Used in: URL shortening endpoints (`/api/urls/shorten`)
   - Fields: originalUrl, shortUrl, creationDate, user (basic info)
   - Usage: Returned after successful URL shortening, contains both original and generated short URL
   - Security: Only includes non-sensitive, necessary URL information


4. ClickEventDTO
   - Used in: Analytics endpoints for tracking URL clicks
   - Purpose: Represents click count data for a specific date
   - Fields: 
     - clickDate (LocalDate): The date when clicks occurred
     - count (Long): Number of clicks on the specific date
   - Usage: 
     - Returned in analytics endpoints to show click trends over time
     - Maps directly to the response structure expected by the frontend
   - Example Response:
     ```json
     [
       {
         "clickDate": "2024-12-01",
         "count": 10
       },
       {
         "clickDate": "2024-12-02",
         "count": 20
       }
     ]
     ```
